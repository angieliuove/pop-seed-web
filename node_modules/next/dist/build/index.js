"use strict";exports.__esModule=true;exports.default=build;var _chalk=_interopRequireDefault(require("chalk"));var _constants=require("next-server/constants");var _nextConfig=_interopRequireDefault(require("next-server/next-config"));var _index=_interopRequireDefault(require("next/dist/compiled/nanoid/index.js"));var _path=_interopRequireDefault(require("path"));var _fs=_interopRequireDefault(require("fs"));var _util=require("util");var _formatWebpackMessages=_interopRequireDefault(require("../client/dev/error-overlay/format-webpack-messages"));var _recursiveDelete=require("../lib/recursive-delete");var _verifyTypeScriptSetup=require("../lib/verifyTypeScriptSetup");var _compiler=require("./compiler");var _entries=require("./entries");var _flyingShuttle=require("./flying-shuttle");var _generateBuildId=require("./generate-build-id");var _isWriteable=require("./is-writeable");var _utils=require("./utils");var _webpackConfig=_interopRequireDefault(require("./webpack-config"));var _chunkGraphPlugin=require("./webpack/plugins/chunk-graph-plugin");var _writeBuildId=require("./write-build-id");var _recursiveReaddir=require("../lib/recursive-readdir");var _mkdirp=_interopRequireDefault(require("mkdirp"));var _workerFarm=_interopRequireDefault(require("worker-farm"));var _asyncSema=require("async-sema");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _wrapRegExp(re,groups){_wrapRegExp=function(re,groups){return new BabelRegExp(re,groups);};var _RegExp=_wrapNativeSuper(RegExp);var _super=RegExp.prototype;var _groups=new WeakMap();function BabelRegExp(re,groups){var _this=_RegExp.call(this,re);_groups.set(_this,groups);return _this;}_inherits(BabelRegExp,_RegExp);BabelRegExp.prototype.exec=function(str){var result=_super.exec.call(this,str);if(result)result.groups=buildGroups(result,this);return result;};BabelRegExp.prototype[Symbol.replace]=function(str,substitution){if(typeof substitution==="string"){var groups=_groups.get(this);return _super[Symbol.replace].call(this,str,substitution.replace(/\$<([^>]+)>/g,function(_,name){return"$"+groups[name];}));}else if(typeof substitution==="function"){var _this=this;return _super[Symbol.replace].call(this,str,function(){var args=[];args.push.apply(args,arguments);if(typeof args[args.length-1]!=="object"){args.push(buildGroups(args,_this));}return substitution.apply(this,args);});}else{return _super[Symbol.replace].call(this,str,substitution);}};function buildGroups(result,re){var g=_groups.get(re);return Object.keys(g).reduce(function(groups,name){groups[name]=result[g[name]];return groups;},Object.create(null));}return _wrapRegExp.apply(this,arguments);}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});if(superClass)_setPrototypeOf(subClass,superClass);}function _possibleConstructorReturn(self,call){if(call&&(typeof call==="object"||typeof call==="function")){return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _wrapNativeSuper(Class){var _cache=typeof Map==="function"?new Map():undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function");}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){return _construct(Class,arguments,_getPrototypeOf(this).constructor);}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf(Wrapper,Class);};return _wrapNativeSuper(Class);}function isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _construct(Parent,args,Class){if(isNativeReflectConstruct()){_construct=Reflect.construct;}else{_construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor();if(Class)_setPrototypeOf(instance,Class.prototype);return instance;};}return _construct.apply(null,arguments);}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf("[native code]")!==-1;}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}const fsUnlink=(0,_util.promisify)(_fs.default.unlink);const fsRmdir=(0,_util.promisify)(_fs.default.rmdir);const fsMove=(0,_util.promisify)(_fs.default.rename);const fsReadFile=(0,_util.promisify)(_fs.default.readFile);const fsWriteFile=(0,_util.promisify)(_fs.default.writeFile);const mkdirp=(0,_util.promisify)(_mkdirp.default);const staticCheckWorker=require.resolve('./static-checker');async function build(dir,conf=null){if(!(await(0,_isWriteable.isWriteable)(dir))){throw new Error('> Build directory is not writeable. https://err.sh/zeit/next.js/build-dir-not-writeable');}await(0,_verifyTypeScriptSetup.verifyTypeScriptSetup)(dir);console.log('Creating an optimized production build ...');console.log();const config=(0,_nextConfig.default)(_constants.PHASE_PRODUCTION_BUILD,dir,conf);const{target}=config;const buildId=await(0,_generateBuildId.generateBuildId)(config.generateBuildId,_index.default);const distDir=_path.default.join(dir,config.distDir);const pagesDir=_path.default.join(dir,'pages');const isFlyingShuttle=Boolean(config.experimental.flyingShuttle&&!process.env.__NEXT_BUILDER_EXPERIMENTAL_PAGE);const selectivePageBuilding=Boolean(isFlyingShuttle||process.env.__NEXT_BUILDER_EXPERIMENTAL_PAGE);if(selectivePageBuilding&&target!=='serverless'){throw new Error(`Cannot use ${isFlyingShuttle?'flying shuttle':'`now dev`'} without the serverless target.`);}const selectivePageBuildingCacheIdentifier=selectivePageBuilding?await(0,_utils.getCacheIdentifier)({pagesDirectory:pagesDir,env:config.env||{}}):'noop';let flyingShuttle;if(isFlyingShuttle){console.log(_chalk.default.magenta('Building with Flying Shuttle enabled ...'));console.log();await(0,_recursiveDelete.recursiveDelete)(distDir,/^(?!cache(?:[\/\\]|$)).*$/);await(0,_recursiveDelete.recursiveDelete)(_path.default.join(distDir,'cache','next-minifier'));await(0,_recursiveDelete.recursiveDelete)(_path.default.join(distDir,'cache','next-babel-loader'));flyingShuttle=new _flyingShuttle.FlyingShuttle({buildId,pagesDirectory:pagesDir,distDirectory:distDir,cacheIdentifier:selectivePageBuildingCacheIdentifier});}let pagePaths;if(process.env.__NEXT_BUILDER_EXPERIMENTAL_PAGE){pagePaths=await(0,_utils.getSpecifiedPages)(dir,process.env.__NEXT_BUILDER_EXPERIMENTAL_PAGE,config.pageExtensions);}else{pagePaths=await(0,_utils.collectPages)(pagesDir,config.pageExtensions);}// needed for static exporting since we want to replace with HTML
// files even when flying shuttle doesn't rebuild the files
const allPagePaths=[...pagePaths];const allStaticPages=new Set();let allPageInfos=new Map();if(flyingShuttle&&(await flyingShuttle.hasShuttle())){allPageInfos=await flyingShuttle.getPageInfos();const _unchangedPages=new Set((await flyingShuttle.getUnchangedPages()));for(const unchangedPage of _unchangedPages){const info=allPageInfos.get(unchangedPage)||{};if(info.static)allStaticPages.add(unchangedPage);const recalled=await flyingShuttle.restorePage(unchangedPage,info);if(recalled){continue;}_unchangedPages.delete(unchangedPage);}const unchangedPages=(await Promise.all([..._unchangedPages].map(async page=>{if(page.endsWith('.amp')&&(allPageInfos.get(page.split('.amp')[0])||{}).isAmp){return'';}const file=await(0,_utils.getFileForPage)({page,pagesDirectory:pagesDir,pageExtensions:config.pageExtensions});if(file){return file;}return Promise.reject(new Error(`Failed to locate page file: ${page}. `+`Did pageExtensions change? We can't recover from this yet.`));}))).filter(Boolean);const pageSet=new Set(pagePaths);for(const unchangedPage of unchangedPages){pageSet.delete(unchangedPage);}pagePaths=[...pageSet];}const allMappedPages=(0,_entries.createPagesMapping)(allPagePaths,config.pageExtensions);const mappedPages=(0,_entries.createPagesMapping)(pagePaths,config.pageExtensions);const entrypoints=(0,_entries.createEntrypoints)(mappedPages,target,buildId,/* dynamicBuildId */selectivePageBuilding,config);const configs=await Promise.all([(0,_webpackConfig.default)(dir,{buildId,isServer:false,config,target,entrypoints:entrypoints.client,selectivePageBuilding}),(0,_webpackConfig.default)(dir,{buildId,isServer:true,config,target,entrypoints:entrypoints.server,selectivePageBuilding})]);let result={warnings:[],errors:[]};if(target==='serverless'){const clientResult=await(0,_compiler.runCompiler)(configs[0]);// Fail build if clientResult contains errors
if(clientResult.errors.length>0){result={warnings:[...clientResult.warnings],errors:[...clientResult.errors]};}else{const serverResult=await(0,_compiler.runCompiler)(configs[1]);result={warnings:[...clientResult.warnings,...serverResult.warnings],errors:[...clientResult.errors,...serverResult.errors]};}}else{result=await(0,_compiler.runCompiler)(configs);}result=(0,_formatWebpackMessages.default)(result);if(isFlyingShuttle){console.log();(0,_chunkGraphPlugin.exportManifest)({dir:dir,fileName:_path.default.join(distDir,_constants.CHUNK_GRAPH_MANIFEST),selectivePageBuildingCacheIdentifier});}if(result.errors.length>0){// Only keep the first error. Others are often indicative
// of the same problem, but confuse the reader with noise.
if(result.errors.length>1){result.errors.length=1;}const error=result.errors.join('\n\n');console.error(_chalk.default.red('Failed to compile.\n'));if(error.indexOf('private-next-pages')>-1&&error.indexOf('does not contain a default export')>-1){const page_name_regex=_wrapRegExp(/\'private-next-pages\/([^\']*)\'/,{page_name:1});const parsed=page_name_regex.exec(error);const page_name=parsed&&parsed.groups&&parsed.groups.page_name;throw new Error(`webpack build failed: found page without a React Component as default export in pages/${page_name}\n\nSee https://err.sh/zeit/next.js/page-without-valid-component for more info.`);}console.error(error);console.error();if(error.indexOf('private-next-pages')>-1){throw new Error('> webpack config.resolve.alias was incorrectly overriden. https://err.sh/zeit/next.js/invalid-resolve-alias');}throw new Error('> Build failed because of webpack errors');}else if(result.warnings.length>0){console.warn(_chalk.default.yellow('Compiled with warnings.\n'));console.warn(result.warnings.join('\n\n'));console.warn();}else{console.log(_chalk.default.green('Compiled successfully.\n'));}const distPath=_path.default.join(dir,config.distDir);const pageKeys=Object.keys(mappedPages);const manifestPath=_path.default.join(distDir,target==='serverless'?_constants.SERVERLESS_DIRECTORY:_constants.SERVER_DIRECTORY,_constants.PAGES_MANIFEST);const staticPages=new Set();const invalidPages=new Set();const pageInfos=new Map();const pagesManifest=JSON.parse((await fsReadFile(manifestPath,'utf8')));let customAppGetInitialProps;process.env.NEXT_PHASE=_constants.PHASE_PRODUCTION_BUILD;const staticCheckSema=new _asyncSema.Sema(config.experimental.cpus,{capacity:pageKeys.length});const staticCheckWorkers=(0,_workerFarm.default)({maxConcurrentWorkers:config.experimental.cpus},staticCheckWorker,['default']);await Promise.all(pageKeys.map(async page=>{const chunks=(0,_chunkGraphPlugin.getPageChunks)(page);const actualPage=page==='/'?'/index':page;const size=await(0,_utils.getPageSizeInKb)(actualPage,distPath,buildId);const bundleRelative=_path.default.join(target==='serverless'?'pages':`static/${buildId}/pages`,actualPage+'.js');const serverBundle=_path.default.join(distPath,target==='serverless'?_constants.SERVERLESS_DIRECTORY:_constants.SERVER_DIRECTORY,bundleRelative);let isStatic=false;pagesManifest[page]=bundleRelative.replace(/\\/g,'/');const runtimeEnvConfig={publicRuntimeConfig:config.publicRuntimeConfig,serverRuntimeConfig:config.serverRuntimeConfig};const nonReservedPage=!page.match(/^\/(_app|_error|_document|api)/);if(nonReservedPage&&customAppGetInitialProps===undefined){customAppGetInitialProps=(0,_utils.hasCustomAppGetInitialProps)(target==='serverless'?serverBundle:_path.default.join(distPath,_constants.SERVER_DIRECTORY,`/static/${buildId}/pages/_app.js`),runtimeEnvConfig);if(customAppGetInitialProps){console.warn(_chalk.default.bold.yellow(`Warning: `)+_chalk.default.yellow(`You have opted-out of Automatic Prerendering due to \`getInitialProps\` in \`pages/_app\`.`));console.warn('Read more: https://err.sh/next.js/opt-out-automatic-prerendering\n');}}if(nonReservedPage){try{await staticCheckSema.acquire();const result=await new Promise((resolve,reject)=>{staticCheckWorkers.default({serverBundle,runtimeEnvConfig},(error,result)=>{if(error)return reject(error);resolve(result||{});});});staticCheckSema.release();if(result.static&&customAppGetInitialProps===false||result.prerender){staticPages.add(page);isStatic=true;}}catch(err){if(err.message!=='INVALID_DEFAULT_EXPORT')throw err;invalidPages.add(page);staticCheckSema.release();}}pageInfos.set(page,{size,chunks,serverBundle,static:isStatic});}));_workerFarm.default.end(staticCheckWorkers);if(invalidPages.size>0){throw new Error(`automatic static optimization failed: found page${invalidPages.size===1?'':'s'} without a React Component as default export in \n${[...invalidPages].map(pg=>`pages${pg}`).join('\n')}\n\nSee https://err.sh/zeit/next.js/page-without-valid-component for more info.\n`);}if(Array.isArray(configs[0].plugins)){configs[0].plugins.some(plugin=>{if(!plugin.ampPages){return false;}plugin.ampPages.forEach(pg=>{pageInfos.get(pg).isAmp=true;});return true;});}await(0,_writeBuildId.writeBuildId)(distDir,buildId,selectivePageBuilding);if(staticPages.size>0){const exportApp=require('../export').default;const exportOptions={silent:true,buildExport:true,pages:Array.from(staticPages),outdir:_path.default.join(distDir,'export')};const exportConfig={...config,exportPathMap:defaultMap=>defaultMap,exportTrailingSlash:false};await exportApp(dir,exportOptions,exportConfig);const toMove=await(0,_recursiveReaddir.recursiveReadDir)(exportOptions.outdir,/.*\.html$/);let serverDir='';// remove server bundles that were exported
for(const page of staticPages){const{serverBundle}=pageInfos.get(page);if(!serverDir){serverDir=_path.default.join(serverBundle.split(/(\/|\\)pages/).shift(),'pages');}await fsUnlink(serverBundle);}for(const file of toMove){const orig=_path.default.join(exportOptions.outdir,file);const dest=_path.default.join(serverDir,file);const relativeDest=(target==='serverless'?_path.default.join('pages',file):_path.default.join('static',buildId,'pages',file)).replace(/\\/g,'/');let page=file.split('.html')[0].replace(/\\/g,'/');pagesManifest[page]=relativeDest;page=page==='/index'?'/':page;pagesManifest[page]=relativeDest;staticPages.add(page);await mkdirp(_path.default.dirname(dest));await fsMove(orig,dest);}// remove temporary export folder
await(0,_recursiveDelete.recursiveDelete)(exportOptions.outdir);await fsRmdir(exportOptions.outdir);await fsWriteFile(manifestPath,JSON.stringify(pagesManifest),'utf8');}staticPages.forEach(pg=>allStaticPages.add(pg));pageInfos.forEach((info,key)=>{allPageInfos.set(key,info);});if(flyingShuttle){await flyingShuttle.mergePagesManifest();await flyingShuttle.save(allStaticPages,pageInfos);}(0,_utils.printTreeView)(Object.keys(allMappedPages),allPageInfos,target==='serverless');}